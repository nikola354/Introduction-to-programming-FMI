## Още типове данни

| Тип               | Размер* bytes(bits) | Допустими стойности              | Аналогични типове** |
|-------------------|---------------------|----------------------------------|----------------------|
| short             | 2 (16)              | [ −2^15 ; 2^15 − 1 ] ∩ ℤ         | int16_t             |
| int               | 4 (32)              | [ −2^31 ; 2^31 − 1 ] ∩ ℤ         | int32_t             |
| long              | 4 (32)              | [ −2^31 ; 2^31 − 1 ] ∩ ℤ         | int32_t             |
| long long         | 8 (64)              | [ −2^63 ; 2^63 − 1 ] ∩ ℤ         | int64_t             |
| unsigned short    | 2 (16)              | [0; 2^16 − 1 ] ∩ ℤ               | uint16_t            |
| unsigned          | 4 (32)              | [0; 2^32 − 1 ] ∩ ℤ               | uint32_t            |
| unsigned long     | 4 (32)              | [0; 2^32 − 1 ] ∩ ℤ               | uint32_t            |
| unsigned long long| 8 (64)              | [0; 2^64 − 1 ] ∩ ℤ               | uint64_t; size_t    |

* \* Това е минималният размер за съответния тип. Точният размер зависи от операционната система и компилатора.
* \*\* Дефинирани в `<cstdint>` и по принцип носят по-добра четимост на кода без да оставят интерпретацията на големината на типа на компилатора. За нашите нужди по-скоро няма да ги ползваме. Придържаме се максимално към най-подходящия тип за нашите цели.

| Тип             | Размер* bytes(bits) | Допустими стойности                     | Аналогични типове**       |
|-----------------|---------------------|-----------------------------------------|----------------------------|
| float           | 4 (32)              | [3.4 · 10^−38 ; 3.4 · 10^38] ∩ ℝ       | *                          |
| double          | 8 (64)              | [1.7 · 10^−308 ; 1.7 · 10^308] ∩ ℝ     | -                          |
| long double     | 8 (64)              | [1.7 · 10^−308 ; 1.7 · 10^308] ∩ ℝ     | -                          |
| char            | 1 (8)               | [−127, 128] ∩ ℤ                         | int8_t                    |
| unsigned char   | 1 (8)               | [0; 255] ∩ ℤ                            | uint8_t, char8_t           |
| bool            | 1 (8)               | 0, 1                                    | -                          |

# Масиви (с фиксирана дължина)

**Масивът** е наредена последователност от елементи от един тип.
Отделен елемент на масива се достъпва посредством името на масива, последвано от поредния номер (индекс) на елемента в квадратни скоби.

```c++
<тип> <име>[<размер>]
```
![array-example](https://media.geeksforgeeks.org/wp-content/uploads/20230302091959/Arrays-in-C.png)

## Инициализация на масиви

```c++
int arr[5]; // Създава масив от 5 елемента, всеки от които е цяло число.
int arr2[] = {34, 21, 2, 66, 567}; // Създава масив от 5 елемента.
int arr3[5] = {1,2,3}; //Останалите елементи се запълват с default-на стойност. 
int arr4[]; //грешка
int arr5[4] = {1, 2, 3, 4, 5} // грешка
```

Задължително големината на масива трябва да е константа, чиято стойност е ясна преди да се компилира програмата.

```c++
int n;
cin >> n;
int arr[n]; //грешка!
```

```c++
const int SIZE = 4;
int arr[SIZE]; //ok!
```

## Достъп на елемент
В масивите имаме константен достъп до всеки един елемент. <br />
Достъпът става посредством индекси. Индексацията започва от 0. <br />

```c++
int arr[] = {1, 2, 400, 4, 5}

arr[3] = 44; //Присвоява на елементът на индекс 3 стойността 44.
             // [1, 2, 400, 44, 5]

std::cout << arr[2]; //Отпечатва на стандартния изход елементът на индекс 2 (400)
```

arr не е самият масив, а **указател към първия елемент**.
```c++
int arr[] = {1, 2, 400, 4, 5}

std::cout << arr; //ще се отпечата АДРЕСА на масива, но не и самия масив.
```

Достъпът до елемент става, чрез смятането адреса му.  <br />
Адресът на arr[i] е: arr + i * sizeof(type of array).  <br />
i е брой "отмествания" надясно.  <br />

## Подаване на масиви във функции
```c++
#include <iostream>

void print(const int arr[], int len) {
	for (int i = 0; i < len; i++) {
		std::cout << arr[i] << " ";
	}
}

void increment(int arr[], unsigned size) {
	for (unsigned i = 0; i < size; i++) {
		arr[i]++;
	}
}

int main() {
	const int SIZE = 4;
	int arr[SIZE]{ 1, 2, 3, 4 };

  	increment(arr, SIZE);
	print(arr, SIZE);

	return 0;
}
```

```c++
#include <iostream>

using namespace std;

void print(const int* arr, int len) {
	for (int i = 0; i < len; i++) {
		std::cout << arr[i] << " ";
	}
}

void increment(int* arr, unsigned size) {
	for (unsigned i = 0; i < size; i++) {
		arr[i]++;
	}
}


int main() {
	const int SIZE = 4;
	int arr[SIZE]{ 1, 2, 3, 4 };

	increment(arr, SIZE);
	print(arr, SIZE);

	return 0;
}
```

Масивите се подават във функциите по адрес!  <br />
Т.е промените, които се правят върху масива във функцията, ще се отразят върху подадения като параметър масив! <br />

```c++

int number = 5;
int *ptr = &number; //указател, който пази адреса на променливата number

std::cout << ptr << endl; //отпечатва адреса на променливата number
std::cout << *ptr << endl; //отпечатва стойността на променливата number (дереференция)
```

### Указател (основа)

Променлива, която пази адрес(memory address) като стойност. <br />
Променливата на указател сочи към типа данни, от същия тип, която е и тя, и се създава чрез оператор *. <br />
Адресът на променливата, с която работим, се присвоява на указателя. <br />

```c++

int number = 5;
int *ptr = &number; //указател, който пази адреса на променливата number

std::cout << ptr << endl; //отпечатва адреса на променливата number
std::cout << *ptr << endl; //отпечатва стойността на променливата number (дереференция)

std::cout << sizeof(ptr); // размерът на самия указател (най-вероятно 8 байта). 
std::cout << sizeof(*ptr); // същото като sizeof(int)


```
*Размерът на указателя не зависи от типа на променливата, към която сочи!*

## Задачи 
- Отпечатване на масив.
- Линейно търсене в масив.
- Обръщане на масив.
- SelectionSort.
- Двоично търсене.
- Решето на Ератостен.
